package gobundler

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"io"
	"path"
	"strings"
)

type PkgWriter struct {
	Writer *strings.Builder
	Buf    bytes.Buffer
	count  int
}

func NewPkgWriter() *PkgWriter {
	sb := &strings.Builder{}
	sb.Grow(4 * 1024) // maybe 1 page
	sb.WriteString(bundleHeader)
	return &PkgWriter{
		Writer: sb,
		Buf:    bytes.Buffer{},
		count:  0,
	}
}

func (p *PkgWriter) WritePackageClause(pkgName string) {
	p.Writer.WriteString(fmt.Sprintf("package %s\n\n", pkgName))
}

func (p *PkgWriter) WriteImportDecl(imports []PkgPath, pkgStrFn func(PkgPath) string) {
	if len(imports) > 0 {
		p.Writer.WriteString("import (\n")
		for _, imp := range imports {
			pkg := imp
			importName := pkgStrFn(pkg)
			p.Writer.WriteString(fmt.Sprintf("\t%s \"%s\"\n", importName, string(pkg)))
		}
		p.Writer.WriteString(")\n\n")
	}
}

const bundleHeader = "// Code generated by github.com/haruyama480/gobundler.\n\n"

const pkgDelimFormat = "" +
	"// ============================================================================\n" +
	"// Package %s\n\n"

const fileDelimFormat = "" +
	"// ----------------------------------------------------------------------------\n" +
	"// File %s\n\n"

func (p *PkgWriter) WritePackage(fset *token.FileSet, files []*ast.File, pkgPath string) error {
	defer func() { p.count++ }()

	if p.count > 0 {
		p.Writer.WriteString("\n\n")
	}
	fmt.Fprintf(p.Writer, pkgDelimFormat, pkgPath)

	for _, file := range files {
		err := p.WriteSubPackage(fset, file)
		if err != nil {
			return err
		}
	}
	return nil
}

// not goroutine safe
func (p *PkgWriter) WriteSubPackage(fset *token.FileSet, file *ast.File) error {
	defer p.Buf.Reset()

	// serialize
	err := format.Node(&p.Buf, fset, file)
	if err != nil {
		return err
	}

	// file header
	fname := fset.Position(file.Pos()).Filename
	base := path.Base(fname)
	fmt.Fprintf(p.Writer, fileDelimFormat, base)

	// skip go:build and package lines
	for {
		line, err := p.Buf.ReadBytes('\n')
		if err != nil {
			return err
		}
		if bytes.HasPrefix(line, []byte("//go:build")) ||
			bytes.HasPrefix(line, []byte("// +build")) {
			continue
		}
		if bytes.HasPrefix(line, []byte("package ")) {
			break
		}
		p.Writer.Write(line)
	}

	// write
	_, err = io.Copy(p.Writer, &p.Buf)
	if err != nil {
		return err
	}

	return nil
}

func (p *PkgWriter) String() string {
	return p.Writer.String()
}
